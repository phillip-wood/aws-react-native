{"ast":null,"code":"'use strict';\n\nvar BoundingDimensions = require(\"./BoundingDimensions\");\n\nvar Position = require(\"./Position\");\n\nvar TouchEventUtils = require('fbjs/lib/TouchEventUtils');\n\nvar keyMirror = require('fbjs/lib/keyMirror');\n\nvar UIManager = require(\"../../apis/UIManager\");\n\nvar States = keyMirror({\n  NOT_RESPONDER: null,\n  RESPONDER_INACTIVE_PRESS_IN: null,\n  RESPONDER_INACTIVE_PRESS_OUT: null,\n  RESPONDER_ACTIVE_PRESS_IN: null,\n  RESPONDER_ACTIVE_PRESS_OUT: null,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: null,\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: null,\n  ERROR: null\n});\nvar IsActive = {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n};\nvar IsPressingIn = {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\nvar IsLongPressingIn = {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\nvar Signals = keyMirror({\n  DELAY: null,\n  RESPONDER_GRANT: null,\n  RESPONDER_RELEASE: null,\n  RESPONDER_TERMINATED: null,\n  ENTER_PRESS_RECT: null,\n  LEAVE_PRESS_RECT: null,\n  LONG_PRESS_DETECTED: null\n});\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n};\nvar HIGHLIGHT_DELAY_MS = 130;\nvar PRESS_EXPAND_PX = 20;\nvar LONG_PRESS_THRESHOLD = 500;\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10;\nvar TouchableMixin = {\n  componentWillUnmount: function componentWillUnmount() {\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n  },\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: {\n        touchState: undefined,\n        responderID: null\n      }\n    };\n  },\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e, dispatchID) {\n    e.persist();\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this._handleDelay(e);\n    }\n\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\n      return;\n    }\n\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left;\n      pressExpandTop += hitSlop.top;\n      pressExpandRight += hitSlop.right;\n      pressExpandBottom += hitSlop.bottom;\n    }\n\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n\n    if (isTouchWithinActive) {\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n\n      var curState = this.state.touchable.touchState;\n\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation(e) {\n    UIManager.measure(e.nativeEvent.target, this._handleQueryLayout);\n  },\n  _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {\n    this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate && BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);\n    this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);\n  },\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n\n    this._receiveSignal(Signals.DELAY, e);\n  },\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (!nextState) {\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\n    }\n\n    if (nextState === States.ERROR) {\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\n    }\n\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n\n      this.state.touchable.touchState = nextState;\n    }\n  },\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    var locationX = touch && touch.locationX;\n    var locationY = touch && touch.locationY;\n    this.pressInLocation = {\n      pageX: pageX,\n      pageY: pageY,\n      locationX: locationX,\n      locationY: locationY\n    };\n  },\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var _this = this;\n\n    var curIsHighlight = this._isHighlight(curState);\n\n    var newIsHighlight = this._isHighlight(nextState);\n\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (!IsActive[curState] && IsActive[nextState]) {\n      this._remeasureMetricsOnActivation(e);\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n\n    if (newIsHighlight && !curIsHighlight) {\n      this._savePressInLocation(e);\n\n      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n    } else if (!newIsHighlight && curIsHighlight && this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (!hasLongPressHandler || !this.touchableLongPressCancelsPress());\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n\n      if (shouldInvokePress && this.touchableHandlePress) {\n        this.touchableHandlePress(e);\n      }\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  }\n};\nvar Touchable = {\n  Mixin: TouchableMixin\n};\nmodule.exports = Touchable;","map":{"version":3,"sources":["/home/phil/Workspace/aws-react-native/node_modules/react-native-web/dist/components/Touchable/Touchable.js"],"names":["BoundingDimensions","require","Position","TouchEventUtils","keyMirror","UIManager","States","NOT_RESPONDER","RESPONDER_INACTIVE_PRESS_IN","RESPONDER_INACTIVE_PRESS_OUT","RESPONDER_ACTIVE_PRESS_IN","RESPONDER_ACTIVE_PRESS_OUT","RESPONDER_ACTIVE_LONG_PRESS_IN","RESPONDER_ACTIVE_LONG_PRESS_OUT","ERROR","IsActive","IsPressingIn","IsLongPressingIn","Signals","DELAY","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","ENTER_PRESS_RECT","LEAVE_PRESS_RECT","LONG_PRESS_DETECTED","Transitions","error","HIGHLIGHT_DELAY_MS","PRESS_EXPAND_PX","LONG_PRESS_THRESHOLD","LONG_PRESS_DELAY_MS","LONG_PRESS_ALLOWED_MOVEMENT","TouchableMixin","componentWillUnmount","touchableDelayTimeout","clearTimeout","longPressDelayTimeout","pressOutDelayTimeout","touchableGetInitialState","touchable","touchState","undefined","responderID","touchableHandleResponderTerminationRequest","props","rejectResponderTermination","touchableHandleStartShouldSetResponder","disabled","touchableLongPressCancelsPress","touchableHandleResponderGrant","e","dispatchID","persist","state","_receiveSignal","delayMS","touchableGetHighlightDelayMS","Math","max","isNaN","setTimeout","_handleDelay","bind","longDelayMS","touchableGetLongPressDelayMS","_handleLongDelay","touchableHandleResponderRelease","touchableHandleResponderTerminate","touchableHandleResponderMove","positionOnActivate","dimensionsOnActivate","pressRectOffset","touchableGetPressRectOffset","left","right","top","bottom","pressExpandLeft","pressExpandTop","pressExpandRight","pressExpandBottom","hitSlop","touchableGetHitSlop","touch","extractSingleTouch","nativeEvent","pageX","pageY","pressInLocation","movedDistance","_getDistanceBetweenPoints","_cancelLongPressDelayTimeout","isTouchWithinActive","width","height","curState","_remeasureMetricsOnActivation","measure","target","_handleQueryLayout","l","t","w","h","globalX","globalY","release","getPooled","console","signal","nextState","Error","_performSideEffectsForTransition","_isHighlight","_savePressInLocation","locationX","locationY","aX","aY","bX","bY","deltaX","deltaY","sqrt","_this","curIsHighlight","newIsHighlight","isFinalSignal","touchableHandleLongPress","touchableHandleActivePressIn","touchableHandleActivePressOut","touchableGetPressOutDelayMS","hasLongPressHandler","onLongPress","pressIsLongButStillCallOnPress","shouldInvokePress","touchableHandlePress","Touchable","Mixin","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n */\n\n'use strict';\n\n/* @edit start */\n\nvar BoundingDimensions = require('./BoundingDimensions');\nvar Position = require('./Position');\nvar TouchEventUtils = require('fbjs/lib/TouchEventUtils');\nvar keyMirror = require('fbjs/lib/keyMirror');\nvar UIManager = require('../../apis/UIManager');\n/* @edit end */\n\n/**\n * `Touchable`: Taps done right.\n *\n * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`\n * will measure time/geometry and tells you when to give feedback to the user.\n *\n * ====================== Touchable Tutorial ===============================\n * The `Touchable` mixin helps you handle the \"press\" interaction. It analyzes\n * the geometry of elements, and observes when another responder (scroll view\n * etc) has stolen the touch lock. It notifies your component when it should\n * give feedback to the user. (bouncing/highlighting/unhighlighting).\n *\n * - When a touch was activated (typically you highlight)\n * - When a touch was deactivated (typically you unhighlight)\n * - When a touch was \"pressed\" - a touch ended while still within the geometry\n *   of the element, and no other element (like scroller) has \"stolen\" touch\n *   lock (\"responder\") (Typically you bounce the element).\n *\n * A good tap interaction isn't as simple as you might think. There should be a\n * slight delay before showing a highlight when starting a touch. If a\n * subsequent touch move exceeds the boundary of the element, it should\n * unhighlight, but if that same touch is brought back within the boundary, it\n * should rehighlight again. A touch can move in and out of that boundary\n * several times, each time toggling highlighting, but a \"press\" is only\n * triggered if that touch ends while within the element's boundary and no\n * scroller (or anything else) has stolen the lock on touches.\n *\n * To create a new type of component that handles interaction using the\n * `Touchable` mixin, do the following:\n *\n * - Initialize the `Touchable` state.\n *\n *   getInitialState: function() {\n *     return merge(this.touchableGetInitialState(), yourComponentState);\n *   }\n *\n * - Choose the rendered component who's touches should start the interactive\n *   sequence. On that rendered node, forward all `Touchable` responder\n *   handlers. You can choose any rendered node you like. Choose a node whose\n *   hit target you'd like to instigate the interaction sequence:\n *\n *   // In render function:\n *   return (\n *     <View\n *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}\n *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}\n *       onResponderGrant={this.touchableHandleResponderGrant}\n *       onResponderMove={this.touchableHandleResponderMove}\n *       onResponderRelease={this.touchableHandleResponderRelease}\n *       onResponderTerminate={this.touchableHandleResponderTerminate}>\n *       <View>\n *         Even though the hit detection/interactions are triggered by the\n *         wrapping (typically larger) node, we usually end up implementing\n *         custom logic that highlights this inner one.\n *       </View>\n *     </View>\n *   );\n *\n * - You may set up your own handlers for each of these events, so long as you\n *   also invoke the `touchable*` handlers inside of your custom handler.\n *\n * - Implement the handlers on your component class in order to provide\n *   feedback to the user. See documentation for each of these class methods\n *   that you should implement.\n *\n *   touchableHandlePress: function() {\n *      this.performBounceAnimation();  // or whatever you want to do.\n *   },\n *   touchableHandleActivePressIn: function() {\n *     this.beginHighlighting(...);  // Whatever you like to convey activation\n *   },\n *   touchableHandleActivePressOut: function() {\n *     this.endHighlighting(...);  // Whatever you like to convey deactivation\n *   },\n *\n * - There are more advanced methods you can implement (see documentation below):\n *   touchableGetHighlightDelayMS: function() {\n *     return 20;\n *   }\n *   // In practice, *always* use a predeclared constant (conserve memory).\n *   touchableGetPressRectOffset: function() {\n *     return {top: 20, left: 20, right: 20, bottom: 100};\n *   }\n */\n\n/**\n * Touchable states.\n */\nvar States = keyMirror({\n  NOT_RESPONDER: null, // Not the responder\n  RESPONDER_INACTIVE_PRESS_IN: null, // Responder, inactive, in the `PressRect`\n  RESPONDER_INACTIVE_PRESS_OUT: null, // Responder, inactive, out of `PressRect`\n  RESPONDER_ACTIVE_PRESS_IN: null, // Responder, active, in the `PressRect`\n  RESPONDER_ACTIVE_PRESS_OUT: null, // Responder, active, out of `PressRect`\n  RESPONDER_ACTIVE_LONG_PRESS_IN: null, // Responder, active, in the `PressRect`, after long press threshold\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: null, // Responder, active, out of `PressRect`, after long press threshold\n  ERROR: null\n});\n\n/**\n * Quick lookup map for states that are considered to be \"active\"\n */\nvar IsActive = {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n};\n\n/**\n * Quick lookup for states that are considered to be \"pressing\" and are\n * therefore eligible to result in a \"selection\" if the press stops.\n */\nvar IsPressingIn = {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\n\nvar IsLongPressingIn = {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n};\n\n/**\n * Inputs to the state machine.\n */\nvar Signals = keyMirror({\n  DELAY: null,\n  RESPONDER_GRANT: null,\n  RESPONDER_RELEASE: null,\n  RESPONDER_TERMINATED: null,\n  ENTER_PRESS_RECT: null,\n  LEAVE_PRESS_RECT: null,\n  LONG_PRESS_DETECTED: null\n});\n\n/**\n * Mapping from States x Signals => States\n */\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n};\n\n// ==== Typical Constants for integrating into UI components ====\n// var HIT_EXPAND_PX = 20;\n// var HIT_VERT_OFFSET_PX = 10;\nvar HIGHLIGHT_DELAY_MS = 130;\n\nvar PRESS_EXPAND_PX = 20;\n\nvar LONG_PRESS_THRESHOLD = 500;\n\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\n\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10;\n\n// Default amount \"active\" region protrudes beyond box\n\n/**\n * By convention, methods prefixed with underscores are meant to be @private,\n * and not @protected. Mixers shouldn't access them - not even to provide them\n * as callback handlers.\n *\n *\n * ========== Geometry =========\n * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n *  +--------------------------+\n *  |                          | - \"Start\" events in `HitRect` cause `HitRect`\n *  |  +--------------------+  |   to become the responder.\n *  |  |  +--------------+  |  | - `HitRect` is typically expanded around\n *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.\n *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,\n *  |  |  |              |  |  |   and before letting up, the Visual React\n *  |  |  +--------------+  |  |   will become \"active\". This makes it eligible\n *  |  |     HitRect        |  |   for being highlighted (so long as the\n *  |  +--------------------+  |   press remains in the `PressRect`).\n *  |        PressRect     o   |\n *  +----------------------|---+\n *           Out Region    |\n *                         +-----+ This gap between the `HitRect` and\n *                                 `PressRect` allows a touch to move far away\n *                                 from the original hit rect, and remain\n *                                 highlighted, and eligible for a \"Press\".\n *                                 Customize this via\n *                                 `touchableGetPressRectOffset()`.\n *\n *\n *\n * ======= State Machine =======\n *\n * +-------------+ <---+ RESPONDER_RELEASE\n * |NOT_RESPONDER|\n * +-------------+ <---+ RESPONDER_TERMINATED\n *     +\n *     | RESPONDER_GRANT (HitRect)\n *     v\n * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+\n * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|\n * +---------------------------+          +-------------------------+                +------------------------------+\n *     +            ^                         +           ^                                 +           ^\n *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_\n *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT\n *     |            |                         |           |                                 |           |\n *     v            +                         v           +                                 v           +\n * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+\n * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|\n * +----------------------------+         +--------------------------+               +-------------------------------+\n *\n * T + DELAY => LONG_PRESS_DELAY_MS + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the `touchableHandlePress` abstract method invocation that occurs\n * when a responder is released while in either of the \"Press\" states.\n *\n * The other important side effects are the highlight abstract method\n * invocations (internal callbacks) to be implemented by the mixer.\n *\n *\n * @lends Touchable.prototype\n */\nvar TouchableMixin = {\n  /**\n   * Clear all timeouts on unmount\n   */\n  componentWillUnmount: function componentWillUnmount() {\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n  },\n\n  /**\n   * It's prefer that mixins determine state in this way, having the class\n   * explicitly mix the state in the one and only `getInitialState` method.\n   *\n   * @return {object} State object to be placed inside of\n   * `this.state.touchable`.\n   */\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: { touchState: undefined, responderID: null }\n    };\n  },\n\n  // ==== Hooks to Gesture Responder system ====\n  /**\n   * Must return true if embedded in a native platform scroll view.\n   */\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n\n  /**\n   * Must return true to start the process of `Touchable`.\n   */\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n\n  /**\n   * Return true to cancel press on long press.\n   */\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderGrant` event.\n   * @param {SyntheticEvent} e Synthetic event from event system.\n   * @param {string} dispatchID ID of node that e was dispatched to.\n   *\n   */\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e, dispatchID) {\n    // Since e is used in a callback invoked on another event loop\n    // (as in setTimeout etc), we need to call e.persist() on the\n    // event to make sure it doesn't get reused in the event object pool.\n    e.persist();\n\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this._handleDelay(e);\n    }\n\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderRelease` event.\n   */\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderTerminate` event.\n   */\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderMove` event.\n   */\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    // Not enough time elapsed yet, wait for highlight -\n    // this is just a perf optimization.\n    if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\n      return;\n    }\n\n    // Measurement may not have returned yet.\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left;\n      pressExpandTop += hitSlop.top;\n      pressExpandRight += hitSlop.right;\n      pressExpandBottom += hitSlop.bottom;\n    }\n\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n    if (isTouchWithinActive) {\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n      var curState = this.state.touchable.touchState;\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\n        // fix for t7967420\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n\n  // ==== Abstract Application Callbacks ====\n\n  /**\n   * Invoked when the item should be highlighted. Mixers should implement this\n   * to visually distinguish the `VisualRect` so that the user knows that\n   * releasing a touch will result in a \"selection\" (analog to click).\n   *\n   * @abstract\n   * touchableHandleActivePressIn: function,\n   */\n\n  /**\n   * Invoked when the item is \"active\" (in that it is still eligible to become\n   * a \"select\") but the touch has left the `PressRect`. Usually the mixer will\n   * want to unhighlight the `VisualRect`. If the user (while pressing) moves\n   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked\n   * again and the mixer should probably highlight the `VisualRect` again. This\n   * event will not fire on an `touchEnd/mouseUp` event, only move events while\n   * the user is depressing the mouse/touch.\n   *\n   * @abstract\n   * touchableHandleActivePressOut: function\n   */\n\n  /**\n   * Invoked when the item is \"selected\" - meaning the interaction ended by\n   * letting up while the item was either in the state\n   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.\n   *\n   * @abstract\n   * touchableHandlePress: function\n   */\n\n  /**\n   * Invoked when the item is long pressed - meaning the interaction ended by\n   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If\n   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will\n   * be called as it normally is. If `touchableHandleLongPress` is provided, by\n   * default any `touchableHandlePress` callback will not be invoked. To\n   * override this default behavior, override `touchableLongPressCancelsPress`\n   * to return false. As a result, `touchableHandlePress` will be called when\n   * lifting up, even if `touchableHandleLongPress` has also been called.\n   *\n   * @abstract\n   * touchableHandleLongPress: function\n   */\n\n  /**\n   * Returns the number of millis to wait before triggering a highlight.\n   *\n   * @abstract\n   * touchableGetHighlightDelayMS: function\n   */\n\n  /**\n   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive\n   * numbers mean the size expands outwards.\n   *\n   * @abstract\n   * touchableGetPressRectOffset: function\n   */\n\n  // ==== Internal Logic ====\n\n  /**\n   * Measures the `HitRect` node on activation. The Bounding rectangle is with\n   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`\n   * should result in points that are in the same coordinate system as an\n   * event's `globalX/globalY` data values.\n   *\n   * - Consider caching this for the lifetime of the component, or possibly\n   *   being able to share this cache between any `ScrollMap` view.\n   *\n   * @sideeffects\n   * @private\n   */\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation(e) {\n    /* @edit begin */\n    UIManager.measure(e.nativeEvent.target, this._handleQueryLayout);\n    /* @edit end */\n  },\n\n  _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {\n    this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate && BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);\n    this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);\n  },\n\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n    this._receiveSignal(Signals.DELAY, e);\n  },\n\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   *\n   * @param {Signals} signal State machine signal.\n   * @throws Error if invalid state transition or unrecognized signal.\n   * @sideeffects\n   */\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n    if (!nextState) {\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\n    }\n    if (nextState === States.ERROR) {\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\n    }\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n      this.state.touchable.touchState = nextState;\n    }\n  },\n\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    var locationX = touch && touch.locationX;\n    var locationY = touch && touch.locationY;\n    this.pressInLocation = { pageX: pageX, pageY: pageY, locationX: locationX, locationY: locationY };\n  },\n\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n\n  /**\n   * Will perform a transition between touchable states, and identify any\n   * highlighting or unhighlighting that must be performed for this particular\n   * transition.\n   *\n   * @param {States} curState Current Touchable state.\n   * @param {States} nextState Next Touchable state.\n   * @param {Signal} signal Signal that triggered the transition.\n   * @param {Event} e Native event.\n   * @sideeffects\n   */\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var _this = this;\n\n    var curIsHighlight = this._isHighlight(curState);\n    var newIsHighlight = this._isHighlight(nextState);\n\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (!IsActive[curState] && IsActive[nextState]) {\n      this._remeasureMetricsOnActivation(e);\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n\n    if (newIsHighlight && !curIsHighlight) {\n      this._savePressInLocation(e);\n      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n    } else if (!newIsHighlight && curIsHighlight && this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing..\n      !hasLongPressHandler || // But either has no long handler\n      !this.touchableLongPressCancelsPress() // or we're told to ignore it.\n      );\n\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n      if (shouldInvokePress && this.touchableHandlePress) {\n        this.touchableHandlePress(e);\n      }\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  }\n\n};\n\nvar Touchable = {\n  Mixin: TouchableMixin\n};\n\nmodule.exports = Touchable;"]},"metadata":{},"sourceType":"script"}